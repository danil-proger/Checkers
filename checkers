import pygame
import enum

WIDTH, HEIGHT = 800, 800
ROWS, COLUMNS = 8, 8
NUMBER_OF_PIECES = 12
SQUARE_SIZE = WIDTH // COLUMNS

PADDING = 15
OUTLINE = 5
OUTLINE_COLOR = (100, 100, 100)
POSSIBLE_MOVE_COLOR = (128, 128, 128)
WHITE_TILES_COLOR = (150, 150, 150)
BLACK_TILES_COLOR = (65, 65, 65)
WHITE_PIECES_COLOR = (255, 255, 255)
BLACK_PIECES_COLOR = (0, 0, 0)

WINDOW = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption('Checkers')


class Pieces(enum.Enum):
    WHITE = 1
    BLACK = 2


class Checker:
    x = 0
    y = 0

    def __init__(self, row, column, team):
        self.row = row
        self.column = column
        self.team = team
        self.calculate_position()

    def calculate_position(self):
        self.x = SQUARE_SIZE * self.column + SQUARE_SIZE // 2
        self.y = SQUARE_SIZE * self.row + SQUARE_SIZE // 2

    def move_rules(self):
        if self.team == Pieces.BLACK:
            return (self.row - 1, self.column - 1), (self.row - 1, self.column + 1)
        return (self.row + 1, self.column - 1), (self.row + 1, self.column + 1)

    def jump_rules(self):
        if self.team == Pieces.BLACK:
            return {(self.row - 2, self.column - 2): (self.row - 1, self.column - 1),
                    (self.row - 2, self.column + 2): (self.row - 1, self.column + 1)}
        return {(self.row + 2, self.column - 2): (self.row + 1, self.column - 1),
                (self.row + 2, self.column + 2): (self.row + 1, self.column + 1)}

    def move(self, row, column):
        self.row = row
        self.column = column
        self.calculate_position()

    def draw(self, window):
        if self.team == Pieces.WHITE:
            color = WHITE_PIECES_COLOR
        else:
            color = BLACK_PIECES_COLOR
        radius = SQUARE_SIZE // 2 - PADDING
        pygame.draw.circle(window, OUTLINE_COLOR, (self.x, self.y), radius + OUTLINE)
        pygame.draw.circle(window, color, (self.x, self.y), radius)


class King(Checker):
    crown_image = pygame.transform.scale(pygame.image.load('images/Crown.png'), (50, 50))

    def move_rules(self):
        return (self.row + 1, self.column - 1), (self.row + 1, self.column + 1), (self.row - 1, self.column - 1), (
            self.row - 1, self.column + 1)

    def jump_rules(self):
        return {(self.row + 2, self.column - 2): (self.row + 1, self.column - 1),
                (self.row + 2, self.column + 2): (self.row + 1, self.column + 1),
                (self.row - 2, self.column - 2): (self.row - 1, self.column - 1),
                (self.row - 2, self.column + 2): (self.row - 1, self.column + 1)}

    def draw(self, window):
        radius = SQUARE_SIZE // 2 - PADDING
        color = WHITE_PIECES_COLOR if self.team == Pieces.WHITE else BLACK_PIECES_COLOR
        pygame.draw.circle(window, OUTLINE_COLOR, (self.x, self.y), radius + OUTLINE)
        pygame.draw.circle(window, color, (self.x, self.y), radius)
        window.blit(self.crown_image,
                    (self.x - self.crown_image.get_width() // 2, self.y - self.crown_image.get_height() // 2))


class Board:
    board = []
    white_pieces_left = NUMBER_OF_PIECES
    black_pieces_left = NUMBER_OF_PIECES
    white_kings_left = 0
    black_kings_left = 0
    last_took = None

    def __init__(self, rows, columns):
        self.rows = rows
        self.columns = columns
        for row_number in range(rows):
            self.board.append([])
            for column_number in range(columns):
                if column_number % 2 == ((row_number + 1) % 2):
                    if row_number < ROWS // 2 - 1:
                        self.board[row_number].append(Checker(row_number, column_number, Pieces.WHITE))
                    elif row_number > ROWS // 2:
                        self.board[row_number].append(Checker(row_number, column_number, Pieces.BLACK))
                    else:
                        self.board[row_number].append(0)
                else:
                    self.board[row_number].append(0)

    def get_tile(self, row, column):
        return self.board[row][column]

    def move(self, piece, row, column):
        self.board[piece.row][piece.column], self.board[row][column] = self.board[row][column], self.board[piece.row][
            piece.column]
        piece.move(row, column)

        if type(piece) == Checker and (row == ROWS - 1 or row == 0):
            if piece.team == BLACK_PIECES_COLOR:
                self.black_kings_left += 1
            else:
                self.white_kings_left += 1

            new_king = King(row, column, piece.team)
            self.board[row][column] = new_king

    def draw(self, window):
        window.fill(BLACK_TILES_COLOR)
        for row in range(self.rows):
            for column in range(row % 2, self.columns, 2):
                pygame.draw.rect(window, WHITE_TILES_COLOR,
                                 (row * SQUARE_SIZE, column * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))

    def get_possible_moves(self, piece):
        moves = {}
        for position in piece.move_rules():
            row, column = position
            if 0 <= row < ROWS and 0 <= column < COLUMNS:
                if self.board[row][column] == 0:
                    moves[position] = None
        return moves

    def get_possible_jumps(self, piece):
        jumps = {}
        all_rules = piece.jump_rules()
        for position in all_rules.keys():
            row, column = position
            if 0 <= row < ROWS and 0 <= column < COLUMNS and self.board[row][column] == 0:
                r, c = all_rules[position]
                if self.board[r][c] != 0 and self.board[r][c].team != piece.team:
                    jumps[position] = (r, c)
        return jumps

    def get_valid_moves(self, piece):
        jumps = self.get_possible_jumps(piece)
        if jumps != {}:
            return jumps
        return self.get_possible_moves(piece)

    def remove(self, piece):
        self.board[piece.row][piece.column] = 0
        if piece.team == Pieces.WHITE:
            self.white_pieces_left -= 1
        else:
            self.black_pieces_left -= 1

    def winner(self):
        if self.white_pieces_left <= 0:
            return Pieces.BLACK
        elif self.black_pieces_left <= 0:
            return Pieces.WHITE
        return None


class Game:
    selected = None
    board = Board(ROWS, COLUMNS)
    turn = Pieces.BLACK
    valid_moves = {}
    forced_to_take = set()

    def __init__(self, window):
        self.window = window

    def update(self):
        self.board.draw(self.window)
        for row in range(ROWS):
            for column in range(COLUMNS):
                piece = Board.board[row][column]
                if piece != 0:
                    piece.draw(self.window)
        self.draw_valid_moves(self.valid_moves)
        pygame.display.update()

    def move_transition(self):
        self.valid_moves.clear()
        self.forced_to_take.clear()
        self.selected = None
        if self.turn == Pieces.BLACK:
            self.turn = Pieces.WHITE
        else:
            self.turn = Pieces.BLACK
        self.find_forced_to_take_pieces()

    def forced_take(self, piece):
        self.valid_moves = {}
        self.forced_to_take.add(piece)
        self.selected = None

    def find_forced_to_take_pieces(self):
        for row in range(ROWS):
            for column in range(COLUMNS):
                piece = self.board.get_tile(row, column)
                if piece != 0 and self.board.get_possible_jumps(piece) != {} and piece.team == self.turn:
                    self.forced_to_take.add(piece)

    def select(self, row, column):
        if self.selected:
            result = self.move_made(row, column)
            if not result:
                self.selected = None
                self.valid_moves.clear()
                self.select(row, column)
        piece = self.board.get_tile(row, column)
        if piece != 0 and piece.team == self.turn:
            self.selected = piece
            if not len(self.forced_to_take) == 0:
                if piece in self.forced_to_take:
                    self.valid_moves = self.board.get_valid_moves(piece)
                else:
                    self.valid_moves.clear()
            else:
                self.valid_moves = self.board.get_valid_moves(piece)
            return True

        return False

    def draw_valid_moves(self, moves):
        for move in moves:
            row, column = move
            pygame.draw.circle(self.window, POSSIBLE_MOVE_COLOR,
                               (column * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2), 15)

    def move_made(self, row, column):
        tile = self.board.get_tile(row, column)
        if self.selected and tile == 0 and (row, column) in self.valid_moves:
            piece_type_before_move = type(self.selected)
            self.board.move(self.selected, row, column)
            taken = self.valid_moves[(row, column)]
            if taken:
                r, c = taken
                taken_piece = self.board.get_tile(r, c)
                self.board.remove(taken_piece)
                piece = self.board.get_tile(row, column)
                if type(piece) == piece_type_before_move and self.board.get_possible_jumps(piece) != {}:
                    self.forced_take(piece)
                else:
                    self.move_transition()
            else:
                self.move_transition()
            return True
        return False

    def winner(self):
        return self.board.winner()


def get_tile_from_mouse(pos):
    x, y = pos
    column = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return row, column


def main():
    run = True
    game = Game(WINDOW)

    while run:
        if game.winner() is not None:
            print(game.winner())
            run = False

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

            if event.type == pygame.MOUSEBUTTONDOWN:
                pos = pygame.mouse.get_pos()
                row, column = get_tile_from_mouse(pos)
                game.select(row, column)

        game.update()

    pygame.quit()


main()
